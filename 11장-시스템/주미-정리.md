# 11장. 시스템

---

## 📍 REVIEW

이번 장은 ‘시스템’이라는 단어 자체가 주는 무게감처럼, 클래스와 함수보다 훨씬 큰 관점에서 코드를 바라보게 한다. 그동안 "잘 짜인 함수", "작은 클래스"에 집중했다면, 이제는 그런 코드들이 유기적으로 연결되어 작동하는 시스템 자체가 얼마나 명확하고 유연해야 하는지를 말해준다.

읽는 내내 머릿속을 맴돈 건 관심사의 분리였다. 시스템이 복잡해지는 이유는 본질적으로 서로 다른 역할이 뒤섞여 있기 때문이라는 점, 그리고 그 복잡성을 줄이는 유일한 해법이 적절한 ‘분리’라는 점에서 공감이 컸다.

단지 구조를 나누는 게 아니라 구성과 실행, 역할과 구현, 비즈니스와 부가 로직을 나눌 줄 아는 것이야말로 좋은 시스템 설계라는 생각이 들었다. 사실 아직 시스템을 설계해본 경험은 많지 않아 크게 와닿기보다는 조금 추상적인 것 같지만, 앞으로 프로그래머로써 항상 고민해봐야 하는 부분일 것이라고 생각되었다.

## 📍 생성과 사용의 분리

### 🔍  왜 분리해야 하는가?

생성과 사용을 동시에 처리하는 코드는 마치, 케이크를 만들면서 동시에 먹는 것과 비슷하다. 준비와 실행은 역할이 전혀 다르기 때문에 섞이면 책임도 섞인다. `getService()` 메서드 하나가 객체를 생성하고 사용하는 로직까지 품고 있다면, 테스트할 때도 이 객체를 무조건 생성해야 하고, 새로운 구현체로 바꾸려면 내부 코드를 수정해야 한다. 이런 구조는 시스템을 점점 경직되게 만든다. 처음엔 편하지만, 갈수록 손대기 어려워진다. 그럼에도 우리 프로젝트의 구조를 조금만 정리해 보면, 그 불편은 의외로 쉽게 줄일 수 있다.

### 🔍  어떻게 분리할 수 있는가?

#### ☑️  main 분리

소프트웨어를 처음 실행할 때 가장 먼저 돌아가는 부분은 보통 `main()`이다. 이 entry point에서 객체를 생성하고, 필요한 것들을 조립해 각 서비스에 넘겨주는 구조를 만든다면, 시스템의 전반적인 구조가 한눈에 들어오기 쉬워진다. 예를 들어, 어떤 객체가 어떤 객체를 필요로 하는지를 일일이 따라가며 파악하는 대신, 시작점에서 모두 정의되어 있으니 ‘전역적인 관점’에서 시스템의 흐름을 조망할 수 있다. 이는 객체 생성의 책임을 사용하는 쪽에서 떼어낸다는 의미이고, 동시에 그 객체가 *어떻게 만들어졌는가*에 대한 정보가 비즈니스 로직에 섞이지 않게 하는 장점도 있다. 시스템의 실행 흐름을 구조적으로 정리하는 가장 기본적인 시작이자, 작지만 매우 강력한 설계 전략이다.

```java

public static void main(String[] args) {
    Fruit fruit = FruitBuilder.getFruit("apple");
    long price = new FruitService().sellFruit(fruit);
    System.out.println("Price: " + price);
}
```

다만, 이 방식의 특징은 모든 의존성 정보가 메인에 집중되기 때문에 규모가 커질수록 이 메인 모듈이 지나치게 비대해질 수 있다는 점이다. 즉, 초반에는 단순하고 명확하지만, 컴포넌트가 많아질수록 main이 의존성 설정과 객체 조합을 일일이 다루어야 하므로 유지보수가 어려워질 수 있다. 또 하나는 재사용성의 한계다. main에서 모든 객체를 고정된 방식으로 조합한다면, 테스트나 환경별 설정에서 유연하게 대응하기 어렵다. 그래서 이 방식은 작고 단순한 애플리케이션에서는 매우 효과적이지만, 규모가 커지면 한계가 분명해진다. 이를 보완하기 위해 더 나은 설계로 이어지는 게 바로 '추상 팩토리'와 '의존성 주입'이다.

#### ☑️  추상 팩토리 패턴

객체 생성의 책임을 완전히 분리하고, 생성의 “구체적인 방법”을 숨기고, “인터페이스”를 통해 생성만 요청할 수 있도록 만든 것이 추상 팩토리 패턴이다. 즉, 메인에서 `Fruit`를 직접 생성하지 않고 `FruitFactory`에게 "사과 하나 줘"라고만 말하면 된다. 내부에서 어떤 클래스가 어떤 방식으로 인스턴스를 만들어내는지 몰라도, 원하는 결과는 얻을 수 있게 되는 것이다. 이 구조는 OCP(Open-Closed Principle, 개방-폐쇄 원칙)를 지키기에 매우 적합하다. 새로운 종류의 `Fruit`이 추가되어도 기존 코드를 거의 건드리지 않아도 된다. 내부 로직만 확장하면 되니까.

```java
public interface FruitFactory {
    Fruit getFruit(String name);
}

public class FruitFactoryImpl implements FruitFactory {
    public Fruit getFruit(String name) {
        return switch (name) {
            case "apple" -> new Apple();
            case "grape" -> new Grape();
            case "orange" -> new Orange();
            default -> throw new IllegalArgumentException("없는 과일");
        };
    }
}
```

이 방식의 가장 큰 특징은 '구성의 유연성'이다. 사용자는 어떤 인스턴스를 생성하든 해당 로직에 대해 전혀 알지 않아도 된다. 그러나 역시 한 가지 주의점이 있다. 인터페이스 기반 구조를 설계해야 하기 때문에 초반 설계에 신중함이 요구되고, 팩토리 구현 클래스가 지나치게 커질 수 있는 위험도 존재한다. 또한 객체 생성에 필요한 복잡한 조건이 많아질수록 팩토리 클래스 자체가 비대해질 수 있는데, 이럴 땐 팩토리 메서드 패턴이나 DI와 결합해 해결해야 한다. 요컨대, 팩토리는 유연성을 주지만 설계 비용이 크고, 모든 상황에 만능은 아니라는 걸 이해하고 적절히 사용하는 것이 핵심이다.

#### ☑️ 의존성 주입(DI)

의존성 주입은 객체가 자신이 사용할 객체를 직접 생성하지 않고, 외부로부터 받아 사용하는 설계 방식이다. 이는 객체지향 설계에서 매우 중요한 패턴으로, 특히 Spring과 같은 프레임워크가 자동으로 처리해주면서 그 중요성이 더 부각되었다. 핵심은 “주입”이라는 단어다. 즉, 내가 무엇을 쓸지 아는 것이 아니라, 누군가가 나에게 적절한 것을 건네주는 방식이다. 이로 인해 객체는 자신의 동작에만 집중할 수 있고, 구성은 다른 클래스 또는 컨테이너가 담당하게 된다.

```java
public class OrderService {
    private final DiscountPolicy discountPolicy;

    public OrderService(DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }
}
```

DI는 테스트의 유연성을 극대화한다. `DiscountPolicy`를 `FixDiscountPolicy`, `RateDiscountPolicy`, 또는 `MockDiscountPolicy`로 갈아끼우기만 하면, 비즈니스 로직은 그대로 두고도 다양한 상황을 테스트할 수 있다. 이처럼 실제 사용하는 구현체에 대한 결합도를 획기적으로 낮출 수 있고, OCP를 완벽하게 만족시킨다. 특징적으로, DI는 생성자 주입, 세터 주입, 필드 주입 등의 다양한 방식으로 구성할 수 있고, Spring에서는 DI 컨테이너가 이 모든 과정을 자동으로 처리해주기도 한다.

단점은 의존성 관계가 명시적으로 외부로 드러나기 때문에, 설정 파일이나 컴포넌트 조립 로직이 복잡해질 수 있다는 점이다. 또한 모든 객체가 DI 기반으로 작성되면 시스템 전체에 걸쳐 의존성 주입 규칙을 따라야 하므로, 설계 초기에 DI 기반으로 구조를 잡지 않았다면 중간에 전환하기가 쉽지 않다. 그럼에도 불구하고, DI는 대규모 시스템에서 유연성과 확장성을 유지하기 위한 거의 필수적인 구조라고 볼 수 있다.

## 📍 횡단 관심사의 분리와 AOP

### 🔍  AOP란?

AOP는 “Aspect Oriented Programming”, 즉 관점 지향 프로그래밍이다.

우리가 평소 작성하는 코드들은 대부분 "기능"을 중심으로 짜인다. 로그인 기능, 결제 기능, 게시판 기능 등. 그런데 이런 코드 안에는 꼭 반복적으로 들어가는 로직들이 있다. 예를 들면, 로그를 남긴다거나, 트랜잭션 처리를 한다거나, 권한을 체크한다거나 하는 것들이다. 이런 걸 AOP에서는 ‘횡단 관심사(Cross-cutting Concern)’라고 부른다. 왜냐하면 이 로직들은 특정 기능에만 붙는 게 아니라 여러 기능에 걸쳐서 동일하게 반복되기 때문이다.

AOP는 이런 반복되는 코드를 *기능에서 분리해서 따로 관리*할 수 있도록 돕는 프로그래밍 방식이다. 예를 들어, 모든 서비스 호출마다 로그를 남기고 싶다고 하자. 이걸 매번 함수 안에 `System.out.println()`으로 적는다면 중복도 많고 보기에도 지저분하다. 하지만 AOP를 쓰면 ‘이 함수가 호출되기 전후로 로그를 출력하라’는 규칙을 코드 바깥에서 선언할 수 있다. 기능은 기능대로, 로깅은 로깅대로 관심사를 나눌 수 있게 되는 것이다. 그리고 이렇게 관심사를 분리하면 각 코드의 역할이 더 명확해지고, 변경도 쉬워지고, 테스트도 편해진다.

### 🔍  어떻게 분리할 수 있는가?

#### ☑️ 자바 프록시

예를 들어, 우리가 어떤 은행 계좌 정보를 불러오고 저장하는 `Bank` 객체가 있다고 해보자. 그런데 이때마다 데이터베이스에서 불러오고, 저장하고 하는 과정에 로그를 남기고 싶다면, `Bank`를 직접 수정하는 대신 그 앞에 프록시 객체를 하나 만들어서 요청을 대신 처리하게 하면 된다.

```java
java
복사편집
Bank bank = (Bank) Proxy.newProxyInstance(
    Bank.class.getClassLoader(),
    new Class[] { Bank.class },
    new BankProxyHandler(new BankImpl())
);

```

이 코드는 `Bank`라는 인터페이스를 구현하는 `BankImpl` 대신, `BankProxyHandler`가 요청을 가로채서 처리하도록 만든다. `BankProxyHandler`는 메소드 호출이 들어올 때마다 `invoke()` 메서드에서 가로채서, 로그를 남기거나 트랜잭션을 붙이거나, 데이터를 조작한 후에 실제 구현체를 호출할 수 있다.

프록시는 AOP의 가장 기본적인 형태다. 하지만 단점도 명확하다.

1. 인터페이스가 반드시 있어야 한다는 점. JDK의 기본 프록시는 인터페이스 기반이다.
2. 코드가 생각보다 장황하고 복잡해진다.
3. 특히 시스템 단위로 적용하기가 어렵고, 개별 객체마다 다 적용해줘야 한다는 불편함이 있다.

즉, 프록시는 "되긴 되는데 너무 번거롭다." 그래서 이걸 좀 더 자동화하고, 유연하게 만든 것이 다음 단계다.

#### ☑️ POJO

POJO는 Plain Old Java Object의 줄임말로, 쉽게 말하면 아무 라이브러리나 프레임워크에 의존하지 않는 순수한 자바 객체를 말한다. 예전에는 비즈니스 로직 하나를 짜도 반드시 특정 프레임워크를 상속하거나 인터페이스를 구현해야 했는데, POJO는 그런 제약 없이 오직 ‘도메인 로직’ 그 자체에만 집중할 수 있게 해준다.

예를 들어, Spring을 사용하는 경우에도 우리는 단순한 `User`, `Bank`, `Account` 클래스들을 아무 설정 없이 만들 수 있다. 프레임워크는 우리가 짠 POJO 클래스에 기능을 붙여줄 뿐이다. 로그를 붙이고, 트랜잭션을 붙이고, 캐시를 붙이고… 모두 프록시나 AOP를 통해 자동으로 이뤄지는 일이다.

이 방식이 좋은 이유는 비즈니스 로직의 테스트가 독립적으로 가능해진다는 점이다. 프레임워크가 없는 환경에서도 동작하고, 재사용도 훨씬 쉽다. 반대로, EJB나 옛날 프레임워크들은 그 객체가 특정 클래스를 상속받아야만 했고, 프레임워크가 없으면 동작하지 않았다. 테스트하려면 무거운 컨테이너를 띄워야만 했던 것이다.

결국 POJO 방식은 "도메인 코드를 도메인 코드답게 짜자"는 철학이고, 그렇게 하기 위해 AOP, DI, 프록시 기술들이 보이지 않는 곳에서 알아서 동작해주는 형태로 진화해온 것이다.

#### ☑️ AspectJ

AspectJ는 AOP를 언어 수준에서 지원하는 도구다. 앞서 본 프록시나 POJO는 모두 런타임에서 프록시 객체를 생성하거나 설정 파일로 연결하는 방식이었는데, AspectJ는 컴파일 시점이나 클래스 로딩 시점에 코드에 AOP 로직을 ‘직접 삽입’해버린다. 그래서 훨씬 강력하고, 유연하다.

예를 들어, 다음과 같은 형태로 코드를 작성할 수 있다.

```java
java
복사편집
@Aspect
public class LoggingAspect {
    @Before("execution(* com.example.service.*.*(..))")
    public void logBeforeMethod(JoinPoint joinPoint) {
        System.out.println("Before: " + joinPoint.getSignature().getName());
    }
}

```

위 코드 한 줄이면, `com.example.service` 하위의 모든 메서드 실행 전에 자동으로 로그가 찍힌다. 이걸 직접 다 프록시로 감싸려면 얼마나 많은 코드를 짜야 할까?

AspectJ의 장점은 분명하다.

- 프록시보다 훨씬 광범위하게 적용할 수 있고
- 조건 지정도 훨씬 정밀하다 (`execution`, `within`, `args` 등으로 복잡한 조건 필터링이 가능)
- 그리고 런타임 오버헤드도 적다.

하지만 단점도 있다.

- 새로운 문법을 배워야 한다는 진입장벽이 있고,
- 컴파일이나 설정이 복잡하며,
- 프레임워크가 아닌 언어 레벨에서 접근하다 보니 디버깅도 어렵다.

그래서 실무에서는 보통 AspectJ보다는 Spring AOP 수준의 단순한 AOP로 80~90%는 해결하고, 정말 필요한 경우에만 AspectJ를 쓴다고 한다. 하지만 ‘관심사를 완전히 분리한다’는 관점에서는 AspectJ가 가장 강력한 도구임에는 틀림없다.

## 📍 더 구조화된 시스템을 위해서

### 🔍  테스트 주도 시스템 아키텍처

#### ☑️ 테스트 주도 시스템 아키텍처

‘테스트 주도 개발(TDD)’은 보통 메서드나 클래스 수준에서 언급되지만, 이 챕터에서는 그것을 시스템 아키텍처의 수준까지 확장해서 설명한다. 개념적으로는 동일하다. 테스트 가능한 구조를 먼저 설계하고, 그에 맞게 시스템을 구성해나간다는 점에서다. 이렇게 설계된 시스템은 테스트가 가능하므로 버그가 적고, 리팩토링에 강하며, 구조적으로도 모듈화가 잘 되어있다.

이를 위해 필요한 전제는 하나다. “각 컴포넌트가 독립적이어야 한다.” 즉, POJO로 구성된 객체들이 있어야 하고, 각 기능은 명확하게 역할이 나뉘어 있어야 하며, 외부 시스템(데이터베이스, 네트워크, 타 프레임워크 등)에 대한 의존성도 주입받는 방식으로 구성되어 있어야 한다.

이런 구조는 처음부터 거창하게 만들 필요는 없다. 작고 잘게 쪼갠 서비스, 테스트 가능한 단위로 구성된 아키텍처를 점차 확장해가며 지속적인 리팩토링과 테스트를 통해 완성도 높은 시스템으로 나아가는 것이 핵심이다.

#### ☑️ 의사 결정의 최적화

이 항목은 사실 소프트웨어 설계뿐 아니라 협업과 커뮤니케이션의 원칙에 가깝다. 소프트웨어는 결국 사람들이 만들어내는 것이고, 결국 의사결정의 흐름이 그 구조와 품질을 좌우한다. 이 장에서 말하는 건 단순하다. 가장 잘 아는 사람이 가장 적절한 시점에 결정할 수 있도록 구조를 짜야 한다는 것이다.

이를 위해서 필요한 것이 바로 DSL(Domain-Specific Language)이다. 도메인 특화 언어는 말 그대로 특정 도메인에 맞춰 만들어진 간결하고 표현력 있는 언어다. 예를 들어, 빌드 도구 Gradle의 설정은 일반적인 자바 문법이 아니라 DSL 형식으로 짜여져 있다. `dependencies` 블록 안에 `implementation 'org.springframework.boot:spring-boot-starter'` 이런 식으로 쓰는 방식. 이게 가능한 이유는 표현하고자 하는 목적이 명확하고, 불필요한 추상화를 덜어냈기 때문이다.

즉, DSL은 의사소통의 간극을 줄여준다. 비개발자와 개발자 간의 협업이 더 쉬워지고, 구현이 더 직관적이 된다. 궁극적으로는 “코드는 인간과의 소통 도구다”라는 철학에 다가가는 방식이다.
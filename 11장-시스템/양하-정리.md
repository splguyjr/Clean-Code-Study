# 11장. 시스템 (Systems)

>[!summary] 나의 요약  
>**11장**은 “시스템” 단위로 코드를 바라보는 관점을 다룹니다.  
>로버트 C. 마틴은 함수, 클래스 레벨에서의 깨끗함뿐만 아니라, 코드가 합쳐져 **큰 그림**을 이룰 때도 여전히 이해하기 쉽고 유지보수 가능한 구조를 가져야 한다고 강조합니다.  
>개인적으로, 이 장을 읽으면서 “전체적인 설계와 팀 협업을 고려한 코드 구성”이 얼마나 중요한지 느꼈습니다. 부분적으로는 깔끔하지만, 시스템 레벨에서 서로 엉켜 있다면 결국 유지보수 지옥에 빠지게 되니까요. **‘레고 블록을 잘 맞추는’** 이미지를 떠올리면서, 각각의 모듈이 어떻게 협력해 커다란 시스템을 이루는지 고민하라는 메시지라고 생각합니다.

---

## 1. 들어가며

> **핵심 개념**  
> - **시스템 레벨에서의 깨끗함**: 함수나 클래스 각각이 깔끔해도, **전체 구조**가 엉망이면 의미가 반감  
> - **높은 단계의 설계**(Architecture)와 **애플리케이션 흐름**을 잘 파악하고, 모듈 간 의존관계가 단순하도록 유지  
> - **빌드/배포/운영**까지 고려해, 시스템 전체가 유연하고 확장 가능해야 진정한 ‘클린 코드’라 할 수 있음

이 장에서는 “큰 그림에서 시스템을 어떻게 조직하고, 모듈과 컴포넌트를 설계하며, 팀 협업 시 어떤 점을 주의해야 하는지”를 중점적으로 다룹니다.

---

## 2. 시스템은 큰 그림을 중요시한다

### 2.1 함수·클래스 → 모듈 → 시스템
- 이전 장들(함수, 클래스)은 로컬한 단위의 클린 코드를 다룸  
- 11장에서는 이들이 모여 **‘시스템’**을 구성할 때,  
  - **API 설계**, **서비스간 의존성**, **데이터 흐름** 등 상위 레벨 설계를 고려해야 한다고 말함

### 2.2 팀 협업과 아키텍처
- 대규모 프로젝트에서는 여러 팀이 동시에 코드를 작성  
- 시스템 구조(모듈 분할, 계층화)가 명확해야 협업이 수월  
- **아키텍처(Architecture)** 원칙에 따라 시스템을 나누고, 각 부분이 **독립적으로** 개발·배포되도록 유도

### 2.3 테스트와 운영 관점
- 시스템 수준에서의 테스트 (통합/시스템 테스트)  
- 배포 파이프라인(CI/CD), 모니터링, 로그 관리 등 **운영 측면**까지 반영해야 제대로 동작하는 완성도 높은 시스템이 됨

---

## 3. 창의적 비유: “레고 블록으로 대형 건축물을 짓기”

- 작은 레고 블록(개별 함수·클래스)을 잘 만들었다고 해서, 거대한 레고 건축물이 자동으로 멋지게 탄생하진 않음
- **시스템 레벨**에서는 각 레고 블록이 **어떻게 연결**될지, 어느 위치에 배치될지,  
  - 전체적인 **설계도**(Architecture)와 **조립 규칙**(Interface, Dependency)이 매우 중요
- 블록들이 제멋대로 붙어 있으면, 뭔가 삐걱거리고 비정상적인 구조가 되어 다른 블록과 호환성이 떨어짐
- 반면 **체계적으로 설계된** 레고 건축물은 **확장**(더 많은 블록을 추가)이나 **재구조화**(블록 일부 교체)도 수월

---

## 4. 시스템 레벨 구조를 깔끔하게 유지하는 방법

### 4.1 계층화(Layered Architecture)
- UI, 비즈니스 로직, 데이터 접근 등을 **명확히 분리**  
- 각 계층이 하위 계층에만 의존, 상위 계층은 몰라도 되는 구조 → **의존성 역전**(DIP) 적용

### 4.2 모듈 분할과 인터페이스 설계
- 모듈(컴포넌트)마다 **명확한 책임**을 갖도록 분리  
- 모듈 간 소통 방식(API, 이벤트, 메서드 호출 등)을 단순·직관적으로 설계

### 4.3 배포와 릴리스 관리
- 시스템 레벨에서 **빌드 프로세스**(Gradle, Maven 등)나 **릴리스 단위**(Microservices 등)를 어떻게 구성할지 결정  
- 변경이 잦은 부분과 안정된 부분을 분리해, 독립된 릴리스 주기 적용

### 4.4 도메인 모델링
- 비즈니스 로직이 복잡한 경우, **도메인 주도 설계(DDD)**나 **풍부한 도메인 모델**을 통해 시스템 전반의 무질서를 예방  
- 시스템 각 부분이 어떤 **도메인 개념**에 해당하는지 명확히 구분

---

## 5. 경계와 오류 처리 다시보기

- 이전 장(8장)에서 다룬 **경계(Boundaries)** 개념이 시스템 레벨에서도 똑같이 적용됨  
- **외부 시스템(서드파티 API, 라이브러리, 연동 서비스)**와의 연결 지점(경계)을 어떻게 처리하느냐에 따라, 전체 구조가 단순해질 수도 복잡해질 수도 있음  
- 오류 처리(7장) 역시 시스템 레벨에서 “어디서 에러를 감지하고, 어떻게 전파해 사용자나 운영자가 인지할 수 있도록 할지”를 설계해야 함

---

## 6. 테스트와 시스템

### 6.1 단위 테스트 vs. 통합 테스트
- 시스템을 테스트하려면, 개별 클래스 수준의 **단위 테스트** 외에 **모듈 간 상호작용**을 검증하는 **통합/시스템 테스트**가 필요  
- 자동화된 테스트 파이프라인(CI/CD)으로, **배포 전**에 전체 시스템 동작을 빠르고 정확하게 확인

### 6.2 스모크 테스트(Smoke Test)
- 릴리스 시점에 **최소한의 시나리오**라도 빠르게 돌려서, 치명적 오류가 없는지 체크  
- 거대한 시스템일수록, “스모크 테스트 → 통합 테스트 → 인수 테스트” 식 계층 구조를 도입해 테스트 효율 상승

---

## 7. 예시: 간단한 전자상거래 시스템

1. **계층 구조**  
   - `Presentation Layer` (Controller)  
   - `Service Layer` (비즈니스 로직)  
   - `Repository / DAO Layer` (데이터 접근)  

2. **모듈 분할**  
   - `OrderModule`, `UserModule`, `PaymentModule` 등 도메인별로 책임 구분  
3. **경계**  
   - 외부 결제 서비스(Stripe, PayPal 등)와 연동하는 `PaymentAdapter`  
   - 상품 데이터가 외부 공급자 API에 의존할 경우 `ProductAdapter`  
4. **운영 관점**  
   - CI 파이프라인에서 스모크 테스트 + 통합 테스트 수행  
   - 모듈별 빌드와 배포를 나눠, 독립적으로 업데이트 가능

---